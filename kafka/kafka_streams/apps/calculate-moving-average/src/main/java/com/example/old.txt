package com.example;

import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.*;
import org.apache.kafka.streams.kstream.*;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.time.Duration;
import java.util.Properties;

public class CalculateMovingAverage {

    public static void main(String[] args) {
        // Kafka Streams Configuration
        Properties props = new Properties();
        props.put(StreamsConfig.APPLICATION_ID_CONFIG, "calculate-moving-averages");
        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "kafka:9092");
        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());
        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass().getName());

        // Build the stream processing topology
        StreamsBuilder builder = new StreamsBuilder();

        // Create the stream for the input topic
        KStream<String, String> inputStream = builder.stream("transformed_data");

        // Define a 10-second sliding window
        final Duration WINDOW_SIZE = Duration.ofSeconds(10);

        KTable<Windowed<String>, SumAndCount> movingAverageTable = inputStream
            .map((key, value) -> {
                // Deserialize JSON
                ObjectMapper objectMapper = new ObjectMapper();
                try {
                    JsonNode jsonNode = objectMapper.readTree(value);
                    // Extract symbol and close_price
                    String symbol = jsonNode.has("symbol") ? jsonNode.get("symbol").asText() : null;
                    String price = jsonNode.has("close_price") ? jsonNode.get("close_price").asText() : null;

                    if (symbol == null || price == null) return null; // Skip invalid records

                    return new KeyValue<>(symbol, price);
                } catch (Exception e) {
                    e.printStackTrace();
                    return null;
                }
            })
            .filter((key, value) -> key != null && value != null) // Ensure key is not null
            .groupByKey() // Now keys are properly set
            .windowedBy(TimeWindows.of(WINDOW_SIZE).advanceBy(WINDOW_SIZE))
            .aggregate(
                SumAndCount::new, // Initialize the aggregator
                (key, value, aggregate) -> {
                    aggregate.add(Double.parseDouble(value)); // Update the sum and count
                    return aggregate;
                },
                Materialized.with(Serdes.String(), new SumAndCountSerde()) // Use custom Serde for SumAndCount
            );

        // Write the result to the output topic
        movingAverageTable.toStream().map((windowedKey, value) -> {
            String symbol = windowedKey.key();
            long windowStartTime = windowedKey.window().start();
            double movingAverage = value.getAverage(); // Calculate the average

            String outputJson = String.format("{\"symbol\":\"%s\", \"time\":%d, \"average_price\": %.4f}",
                    symbol, windowStartTime, movingAverage);
            return new KeyValue<>(symbol, outputJson); // Use symbol as key
        }).to("moving_average_prices", Produced.with(Serdes.String(), Serdes.String())); // Fix key serde

        // Start Kafka Streams
        KafkaStreams streams = new KafkaStreams(builder.build(), props);
        streams.start();
    }
}
